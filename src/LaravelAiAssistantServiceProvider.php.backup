<?php

declare(strict_types=1);

namespace CreativeCrafts\LaravelAiAssistant;

use CreativeCrafts\LaravelAiAssistant\Compat\OpenAI\Client;
use CreativeCrafts\LaravelAiAssistant\Contracts\AiAssistantContract;
use CreativeCrafts\LaravelAiAssistant\Contracts\AssistantResourceContract;
use CreativeCrafts\LaravelAiAssistant\Contracts\ConversationsRepositoryContract;
use CreativeCrafts\LaravelAiAssistant\Contracts\FilesRepositoryContract;
use CreativeCrafts\LaravelAiAssistant\Contracts\OpenAiRepositoryContract;
use CreativeCrafts\LaravelAiAssistant\Contracts\ResponsesRepositoryContract;
use CreativeCrafts\LaravelAiAssistant\Contracts\Storage\AssistantsStoreContract;
use CreativeCrafts\LaravelAiAssistant\Contracts\Storage\ConversationItemsStoreContract;
use CreativeCrafts\LaravelAiAssistant\Contracts\Storage\ConversationsStoreContract;
use CreativeCrafts\LaravelAiAssistant\Contracts\Storage\ResponsesStoreContract;
use CreativeCrafts\LaravelAiAssistant\Contracts\Storage\ToolInvocationsStoreContract;
use CreativeCrafts\LaravelAiAssistant\Exceptions\ConfigurationValidationException;
use CreativeCrafts\LaravelAiAssistant\Http\Controllers\WebhookController;
use CreativeCrafts\LaravelAiAssistant\Jobs\ExecuteToolCallJob;
use CreativeCrafts\LaravelAiAssistant\Repositories\Http\ConversationsHttpRepository;
use CreativeCrafts\LaravelAiAssistant\Repositories\Http\FilesHttpRepository;
use CreativeCrafts\LaravelAiAssistant\Repositories\Http\ResponsesHttpRepository;
use CreativeCrafts\LaravelAiAssistant\Repositories\NullOpenAiRepository;
use CreativeCrafts\LaravelAiAssistant\Repositories\OpenAiRepository;
use CreativeCrafts\LaravelAiAssistant\Services\AiManager;
use CreativeCrafts\LaravelAiAssistant\Services\AppConfig;
use CreativeCrafts\LaravelAiAssistant\Services\AssistantService;
use CreativeCrafts\LaravelAiAssistant\Services\BackgroundJobService;
use CreativeCrafts\LaravelAiAssistant\Services\CacheService;
use CreativeCrafts\LaravelAiAssistant\Services\ErrorReportingService;
use CreativeCrafts\LaravelAiAssistant\Services\IdempotencyService;
use CreativeCrafts\LaravelAiAssistant\Services\LazyLoadingService;
use CreativeCrafts\LaravelAiAssistant\Services\LoggingService;
use CreativeCrafts\LaravelAiAssistant\Services\MemoryMonitoringService;
use CreativeCrafts\LaravelAiAssistant\Services\MetricsCollectionService;
use CreativeCrafts\LaravelAiAssistant\Services\ResponseStatusStore;
use CreativeCrafts\LaravelAiAssistant\Services\SecurityService;
use CreativeCrafts\LaravelAiAssistant\Services\Storage\EloquentAssistantsStore;
use CreativeCrafts\LaravelAiAssistant\Services\Storage\EloquentConversationItemsStore;
use CreativeCrafts\LaravelAiAssistant\Services\Storage\EloquentConversationsStore;
use CreativeCrafts\LaravelAiAssistant\Services\Storage\EloquentResponsesStore;
use CreativeCrafts\LaravelAiAssistant\Services\Storage\EloquentToolInvocationsStore;
use CreativeCrafts\LaravelAiAssistant\Services\Storage\InMemoryAssistantsStore;
use CreativeCrafts\LaravelAiAssistant\Services\Storage\InMemoryConversationItemsStore;
use CreativeCrafts\LaravelAiAssistant\Services\Storage\InMemoryConversationsStore;
use CreativeCrafts\LaravelAiAssistant\Services\Storage\InMemoryResponsesStore;
use CreativeCrafts\LaravelAiAssistant\Services\Storage\InMemoryToolInvocationsStore;
use CreativeCrafts\LaravelAiAssistant\Services\StreamingService;
use CreativeCrafts\LaravelAiAssistant\Services\ThreadsToConversationsMapper;
use CreativeCrafts\LaravelAiAssistant\Services\ToolRegistry;
use Exception;
use GuzzleHttp\Client as GuzzleClient;
use Illuminate\Support\Facades\Bus;
use Illuminate\Support\Facades\Config;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Route;
use Spatie\LaravelPackageTools\Package;
use Spatie\LaravelPackageTools\PackageServiceProvider;

class LaravelAiAssistantServiceProvider extends PackageServiceProvider
{
    public function configurePackage(Package $package): void
    {
        $package
            ->name('laravel-ai-assistant')
            ->hasConfigFile()
            ->hasMigrations(['create_ai_assistant_tables']);
    }

    public function packageRegistered(): void
    {
        // Register the OpenAI Client as a singleton
        $this->app->singleton(Client::class, function ($app) {
            return AppConfig::openAiClient();
        });

        // Register the Cache Service as a singleton
        $this->app->singleton(CacheService::class);

        // Register the Logging Service as a singleton
        $this->app->singleton(LoggingService::class);

        // Register Idempotency Service as a singleton
        $this->app->singleton(IdempotencyService::class);

        // Register Security Service as a singleton (used for configuration validation and request signing)
        $this->app->singleton(SecurityService::class, function ($app) {
            return new SecurityService(
                $app->make(CacheService::class),
                $app->make(LoggingService::class)
            );
        });

        // Register ResponseStatusStore as a singleton
        $this->app->singleton(ResponseStatusStore::class, function ($app) {
            return new ResponseStatusStore($app->make(CacheService::class));
        });

        // Register storage singletons based on configured persistence driver
        $driver = config('ai-assistant.persistence.driver', 'memory');
        if (!is_string($driver)) {
            $driver = 'memory';
        }
        if ($driver === 'eloquent') {
            $this->app->singleton(AssistantsStoreContract::class, function ($app) {
                return new EloquentAssistantsStore();
            });
            $this->app->singleton(ConversationsStoreContract::class, function ($app) {
                return new EloquentConversationsStore();
            });
            $this->app->singleton(ConversationItemsStoreContract::class, function ($app) {
                return new EloquentConversationItemsStore();
            });
            $this->app->singleton(ResponsesStoreContract::class, function ($app) {
                return new EloquentResponsesStore();
            });
            $this->app->singleton(ToolInvocationsStoreContract::class, function ($app) {
                return new EloquentToolInvocationsStore();
            });
        } else {
            $this->app->singleton(AssistantsStoreContract::class, function ($app) {
                return new InMemoryAssistantsStore();
            });
            $this->app->singleton(ConversationsStoreContract::class, function ($app) {
                return new InMemoryConversationsStore();
            });
            $this->app->singleton(ConversationItemsStoreContract::class, function ($app) {
                return new InMemoryConversationItemsStore();
            });
            $this->app->singleton(ResponsesStoreContract::class, function ($app) {
                return new InMemoryResponsesStore();
            });
            $this->app->singleton(ToolInvocationsStoreContract::class, function ($app) {
                return new InMemoryToolInvocationsStore();
            });
        }

        // Register ThreadsToConversationsMapper for backward compatibility
        $this->app->singleton(ThreadsToConversationsMapper::class, function ($app) {
            return new ThreadsToConversationsMapper($app->make(CacheService::class));
        });

        // Register performance optimization and monitoring services as singletons
        $this->app->singleton(MemoryMonitoringService::class, function ($app) {
            return new MemoryMonitoringService(
                $app->make(LoggingService::class),
                (array)(config('ai-assistant.memory_monitoring') ?? [])
            );
        });
        $this->app->singleton(MetricsCollectionService::class, function ($app) {
            return new MetricsCollectionService(
                $app->make(LoggingService::class),
                (array)(config('ai-assistant.metrics') ?? [])
            );
        });
        $this->app->singleton(ErrorReportingService::class, function ($app) {
            return new ErrorReportingService(
                $app->make(LoggingService::class),
                (array)(config('ai-assistant.error_reporting') ?? [])
            );
        });

        // Register ToolRegistry singleton
        $this->app->singleton(ToolRegistry::class, function ($app) {
            $registry = new ToolRegistry();
            $executor = config('ai-assistant.tool_calling.executor', 'sync');
            if (!is_string($executor)) {
                $executor = 'sync';
            }
            if ($executor === 'queue') {
                // Configure a queue-backed executor. It dispatches jobs; if __parallel is true, use async dispatch, else dispatchSync.
                $registry->setExecutor(function (callable $fn, array $args) {
                    $name = $args['__name'] ?? null;
                    $parallel = (bool)($args['__parallel'] ?? false);
                    if (isset($args['__name'])) {
                        unset($args['__name']);
                    }
                    if (isset($args['__parallel'])) {
                        unset($args['__parallel']);
                    }
                    if (is_string($name) && $name !== '') {
                        if ($parallel) {
                            Log::info('[AI Assistant] Queue executor: dispatch async tool job', ['tool' => $name]);
                            // Fire-and-forget; we cannot collect results in true async without extra storage.
                            // For SDK determinism, we still return the immediate inline result to the caller.
                            Bus::dispatch(new ExecuteToolCallJob($name, $args));
                            return $fn($args);
                        }
                        Log::info('[AI Assistant] Queue executor: dispatch sync tool job', ['tool' => $name]);
                        return Bus::dispatchSync(
                            new ExecuteToolCallJob($name, $args)
                        );
                    }
                    // Fallback: execute inline
                    return $fn($args);
                });
            }
            return $registry;
        });

        // Register a streaming service with dependencies
        $this->app->singleton(StreamingService::class, function ($app) {
            return new StreamingService(
                $app->make(LoggingService::class),
                $app->make(MemoryMonitoringService::class),
                (array)(config('ai-assistant.streaming') ?? [])
            );
        });

        // Register background job service with dependencies
        $this->app->singleton(BackgroundJobService::class, function ($app) {
            return new BackgroundJobService(
                $app->make(LoggingService::class),
                $app->make(MetricsCollectionService::class),
                (array)(config('ai-assistant.background_jobs') ?? [])
            );
        });

        // Register lazy loading service as singleton
        $this->app->singleton(LazyLoadingService::class, function ($app) {
            return new LazyLoadingService(
                $app->make(LoggingService::class)
            );
        });

        // Unified entrypoint service: AiManager
        $this->app->singleton(AiManager::class, function ($app) {
            return new AiManager();
        });

        // Register the OpenAI Repository with dependency injection honoring config overrides
        $this->app->bind(OpenAiRepository::class, function ($app) {
            return new OpenAiRepository($app->make(Client::class));
        });
        $this->app->bind(OpenAiRepositoryContract::class, function ($app) {
            $useMock = (bool)config('ai-assistant.mock_responses', false);
            if ($useMock) {
                return $app->make(NullOpenAiRepository::class);
            }
            $override = config('ai-assistant.repository');
            if (is_string($override) && $override !== '') {
                // Validate implements contract; if not, throw a clear configuration exception
                if (!class_exists($override)) {
                    throw new ConfigurationValidationException("Configured ai-assistant.repository class '{$override}' does not exist.");
                }
                if (!is_subclass_of($override, OpenAiRepositoryContract::class)) {
                    throw new ConfigurationValidationException("Configured ai-assistant.repository class '{$override}' must implement " . OpenAiRepositoryContract::class);
                }
                return $app->make($override);
            }
            return $app->make(OpenAiRepository::class);
        });

        // Register new HTTP repositories for Responses, Conversations, and Files
        $this->app->bind(ResponsesRepositoryContract::class, function ($app) {
            $apiKey = config('ai-assistant.api_key', '');
            if (!is_string($apiKey)) {
                $apiKey = '';
            }
            $org = config('ai-assistant.organization');
            $headers = [
                'Authorization' => 'Bearer ' . $apiKey,
                'Accept' => 'application/json',
            ];
            if (is_string($org) && $org !== '' && $org !== 'YOUR_OPENAI_ORGANIZATION' && $org !== 'your-organization-id-here') {
                $headers['OpenAI-Organization'] = $org;
            }
            $timeout = config('ai-assistant.responses.timeout', 120);
            if (!is_numeric($timeout)) {
                $timeout = 120;
            }
            $client = new GuzzleClient([
                'base_uri' => 'https://api.openai.com',
                'headers' => $headers,
                'http_errors' => false,
                'timeout' => (float)$timeout,
                'connect_timeout' => 10,
            ]);
            return new ResponsesHttpRepository($client);
        });

        $this->app->bind(ConversationsRepositoryContract::class, function ($app) {
            $apiKey = config('ai-assistant.api_key', '');
            if (!is_string($apiKey)) {
                $apiKey = '';
            }
            $org = config('ai-assistant.organization');
            $headers = [
                'Authorization' => 'Bearer ' . $apiKey,
                'Accept' => 'application/json',
            ];
            if (is_string($org) && $org !== '' && $org !== 'YOUR_OPENAI_ORGANIZATION' && $org !== 'your-organization-id-here') {
                $headers['OpenAI-Organization'] = $org;
            }
            $timeout = config('ai-assistant.responses.timeout', 120);
            if (!is_numeric($timeout)) {
                $timeout = 120;
            }
            $client = new GuzzleClient([
                'base_uri' => 'https://api.openai.com',
                'headers' => $headers,
                'http_errors' => false,
                'timeout' => (float)$timeout,
                'connect_timeout' => 10,
            ]);
            return new ConversationsHttpRepository($client);
        });

        $this->app->bind(FilesRepositoryContract::class, function ($app) {
            $apiKey = config('ai-assistant.api_key', '');
            if (!is_string($apiKey)) {
                $apiKey = '';
            }
            $org = config('ai-assistant.organization');
            $headers = [
                'Authorization' => 'Bearer ' . $apiKey,
                'Accept' => 'application/json',
            ];
            if (is_string($org) && $org !== '' && $org !== 'YOUR_OPENAI_ORGANIZATION' && $org !== 'your-organization-id-here') {
                $headers['OpenAI-Organization'] = $org;
            }
            $timeout = config('ai-assistant.responses.timeout', 120);
            if (!is_numeric($timeout)) {
                $timeout = 120;
            }
            $client = new GuzzleClient([
                'base_uri' => 'https://api.openai.com',
                'headers' => $headers,
                'http_errors' => false,
                'timeout' => (float)$timeout,
                'connect_timeout' => 10,
            ]);
            return new FilesHttpRepository($client);
        });

        // Register OpenAIClientFacade to unify repositories and legacy chat
        $this->app->singleton(OpenAIClientFacade::class, function ($app) {
            return new OpenAIClientFacade(
                $app->make(ResponsesRepositoryContract::class),
                $app->make(ConversationsRepositoryContract::class),
                $app->make(FilesRepositoryContract::class),
                $app->make(OpenAiRepositoryContract::class)
            );
        });

        // Register the AssistantService with repository and cache dependency injection
        $this->app->bind(AssistantResourceContract::class, AssistantService::class);
        $this->app->bind(AssistantService::class, function ($app) {
            return new AssistantService(
                $app->make(OpenAiRepositoryContract::class),
                $app->make(CacheService::class)
            );
        });

        // Register the main AiAssistant class
        $this->app->bind(AiAssistantContract::class, AiAssistant::class);
        $this->app->bind(AiAssistant::class, function ($app) {
            $assistant = new AiAssistant();
            $assistant->client($app->make(AssistantService::class));
            return $assistant;
        });

        // Register the Assistant class
        $this->app->bind(Assistant::class, function ($app) {
            $assistant = new Assistant();
            $assistant->client($app->make(AssistantService::class));
            return $assistant;
        });

        // Register convenient aliases for the main classes
        $this->app->alias(AiAssistant::class, 'ai-assistant');
        $this->app->alias(Assistant::class, 'assistant');
    }

    public function packageBooted(): void
    {
        // Apply environment overlay defaults before validation so tests and runtime
        // overrides remain the highest priority.
        $this->applyEnvironmentOverlayDefaults();

        if (!app()->runningUnitTests() && !defined('PHPSTAN_RUNNING')) {
            $this->validateConfiguration();
        }

        // Register webhook route if enabled
        $webhooksEnabled = config('ai-assistant.webhooks.enabled', false);
        if ($webhooksEnabled) {
            $path = config('ai-assistant.webhooks.path', '/ai-assistant/webhook');
            if (!is_string($path)) {
                $path = '/ai-assistant/webhook';
            }

            // Read individual route config keys to ensure runtime overrides are respected
            $routeName = config('ai-assistant.webhooks.route.name', 'ai-assistant.webhook');
            if (!is_string($routeName)) {
                $routeName = 'ai-assistant.webhook';
            }

            // Support two keys for BC: webhooks.middleware (new) and webhooks.route.middleware (old)
            $routeMiddleware = config('ai-assistant.webhooks.middleware', config('ai-assistant.webhooks.route.middleware', []));
            if (is_string($routeMiddleware)) {
                // Support comma or pipe separated middleware strings
                $routeMiddleware = preg_split('/[|,]/', $routeMiddleware) ?: [];
                $routeMiddleware = array_values(array_filter(array_map('trim', $routeMiddleware), fn($m) => $m !== ''));
            } elseif (!is_array($routeMiddleware)) {
                $routeMiddleware = [];
            }

            $prefix = config('ai-assistant.webhooks.route.group.prefix');
            $groupMiddleware = config('ai-assistant.webhooks.route.group.middleware', []);
            if (is_string($groupMiddleware)) {
                $groupMiddleware = preg_split('/[|,]/', $groupMiddleware) ?: [];
                $groupMiddleware = array_values(array_filter(array_map('trim', $groupMiddleware), fn($m) => $m !== ''));
            } elseif (!is_array($groupMiddleware)) {
                $groupMiddleware = [];
            }

            $register = function () use ($path, $routeName, $routeMiddleware) {
                $route = Route::post($path, [WebhookController::class, 'handle'])->name($routeName);
                if (!empty($routeMiddleware)) {
                    $route->middleware($routeMiddleware);
                }
            };

            $groupOptions = [];
            if (!empty($prefix)) {
                $groupOptions['prefix'] = $prefix;
            }
            if (!empty($groupMiddleware)) {
                $groupOptions['middleware'] = $groupMiddleware;
            }

            if (!empty($groupOptions)) {
                Route::group($groupOptions, $register);
            } else {
                $register();
            }
        }

        // Publish model stubs for developers to customize
        $this->publishes([
            __DIR__ . '/../stubs/models/AssistantProfile.php.stub' => app_path('Models/AssistantProfile.php'),
            __DIR__ . '/../stubs/models/Conversation.php.stub' => app_path('Models/Conversation.php'),
            __DIR__ . '/../stubs/models/ConversationItem.php.stub' => app_path('Models/ConversationItem.php'),
            __DIR__ . '/../stubs/models/ResponseRecord.php.stub' => app_path('Models/ResponseRecord.php'),
            __DIR__ . '/../stubs/models/ToolInvocation.php.stub' => app_path('Models/ToolInvocation.php'),
        ], 'ai-assistant-models');

        // Publish migrations with a timestamp for easy customization
        $timestamp = date('Y_m_d_His');
        $this->publishes([
            __DIR__ . '/../database/migrations/create_ai_assistant_tables.php' => database_path("migrations/{$timestamp}_create_ai_assistant_tables.php"),
        ], 'ai-assistant-migrations');
    }

    /**
     * Apply environment overlay defaults into ai-assistant config with predictable precedence.
     * Precedence (highest to lowest):
     *  - Runtime overrides (config([...]) / env())
     *  - Environment overlay defaults (config/environments/{env}.php)
     *  - Base package config (config/ai-assistant.php)
     */
    protected function applyEnvironmentOverlayDefaults(): void
    {
        // Read the current config (may already include runtime overrides set before boot)
        $current = Config::get('ai-assistant', []);
        $current = is_array($current) ? $current : [];

        // Load base package config directly from file to compare and compose
        $base = $this->loadPackageBaseConfig();

        // Determine overlay path(s) based on environment
        $env = $this->app->environment();
        $overlayPath = null;
        if (in_array($env, ['local', 'development'], true)) {
            $overlayPath = __DIR__ . '/../config/environments/development.php';
        } elseif ($env === 'testing') {
            $overlayPath = __DIR__ . '/../config/environments/testing.php';
        } elseif ($env === 'production') {
            $overlayPath = __DIR__ . '/../config/environments/production.php';
        }

        $overlay = [];
        if ($overlayPath && is_file($overlayPath)) {
            $loaded = require $overlayPath;
            if (is_array($loaded)) {
                $overlay = $loaded;
            }
        }

        // Compose with precedence: overlay overrides base defaults for the current environment
        $composed = $this->arrayReplaceRecursive($base, $overlay);

        // Compute runtime overrides as the delta between current config and base
        $runtimeOverrides = $this->arrayRecursiveDiff($current, $base);

        // Final: composed overridden by runtime overrides
        $final = $this->arrayReplaceRecursive($composed, $runtimeOverrides);

        Config::set('ai-assistant', $final);
    }

    /**
     * Load the package base configuration array from file without going through Config facade.
     */
    private function loadPackageBaseConfig(): array
    {
        $path = __DIR__ . '/../config/ai-assistant.php';
        if (is_file($path)) {
            $data = require $path;
            if (is_array($data)) {
                return $data;
            }
        }
        // Fallback to whatever is currently in config if file missing
        $current = Config::get('ai-assistant', []);
        return is_array($current) ? $current : [];
    }

    /**
     * array_replace_recursive wrapper with type-safety for arrays.
     * Later arrays override earlier ones, recursively.
     *
     * @param array $base
     * @param array ...$replacements
     */
    private function arrayReplaceRecursive(array $base, array ...$replacements): array
    {
        return array_replace_recursive($base, ...$replacements);
    }

    /**
     * Compute a recursive difference: keys where $a differs from $b (or new keys in $a).
     * Used to extract runtime overrides compared to base config.
     */
    private function arrayRecursiveDiff(array $a, array $b): array
    {
        $diff = [];
        foreach ($a as $key => $value) {
            if (!array_key_exists($key, $b)) {
                $diff[$key] = $value;
                continue;
            }
            $bVal = $b[$key];
            if (is_array($value) && is_array($bVal)) {
                $sub = $this->arrayRecursiveDiff($value, $bVal);
                if ($sub !== []) {
                    $diff[$key] = $sub;
                }
            } elseif ($value !== $bVal) {
                $diff[$key] = $value;
            }
        }
        return $diff;
    }

    /**
     * Validate the package configuration.
     *
     * @throws ConfigurationValidationException When configuration is invalid
     */
    protected function validateConfiguration(): void
    {
        $config = Config::get('ai-assistant');

        if (empty($config)) {
            throw new ConfigurationValidationException('AI Assistant configuration not found. Please publish the configuration file.');
        }

        // Ensure config is an array for type safety
        if (!is_array($config)) {
            throw new ConfigurationValidationException('AI Assistant configuration must be an array.');
        }

        $this->validateRequiredSettings($config);
        $this->validateModelConfiguration($config);
        $this->validateParameterRanges($config);
        $this->validateAdvancedConfiguration($config);
        $this->validateWebhooksConfiguration($config);
        $this->validateEnvironmentSpecificSettings($config);
    }

    /**
     * Validate required configuration settings.
     *
     * @param array $config Configuration array
     * @throws ConfigurationValidationException When required settings are missing
     */
    protected function validateRequiredSettings(array $config): void
    {
        $required = ['api_key'];
        $missing = [];

        foreach ($required as $key) {
            if (empty($config[$key])) {
                $missing[] = $key;
            }
        }

        if (!empty($missing)) {
            throw new ConfigurationValidationException(
                'Missing required configuration values: ' . implode(', ', $missing) .
                '. Please set these in your .env file or config/ai-assistant.php'
            );
        }

        // Validate API key format using SecurityService only in strict environments
        $env = $this->app->environment();
        $strictValidate = ($env === 'production');
        if ($strictValidate && $this->app->bound(SecurityService::class)) {
            try {
                $securityService = $this->app->make(SecurityService::class);
                $securityService->validateApiKey($config['api_key']);
            } catch (Exception $e) {
                throw new ConfigurationValidationException(
                    'Invalid API key configuration: ' . $e->getMessage()
                );
            }
        }
    }

    /**
     * Validate model configuration settings.
     *
     * @param array $config Configuration array
     * @throws ConfigurationValidationException When model configuration is invalid
     */
    protected function validateModelConfiguration(array $config): void
    {
        $models = ['chat_model', 'edit_model', 'audio_model'];

        foreach ($models as $modelKey) {
            if (!array_key_exists($modelKey, $config) || $config[$modelKey] === null || $config[$modelKey] === '') {
                throw new ConfigurationValidationException(
                    "Missing model configuration '{$modelKey}'. Set the appropriate OPENAI_*_MODEL environment variable or config('ai-assistant.{$modelKey}')."
                );
            }
            if (!is_string($config[$modelKey])) {
                throw new ConfigurationValidationException(
                    "Model configuration '{$modelKey}' must be a string."
                );
            }
        }

        $chat = (string)$config['chat_model'];
        $edit = (string)$config['edit_model'];
        $audio = (string)$config['audio_model'];

        $errors = [];
        if (!str_starts_with($chat, 'gpt-')) {
            $errors[] = "chat_model '{$chat}' is invalid. Expected a GPT family model (e.g., gpt-4o, gpt-4o-mini, gpt-4-turbo). Set OPENAI_CHAT_MODEL.";
        }
        if (!str_starts_with($edit, 'gpt-')) {
            $errors[] = "edit_model '{$edit}' is invalid. Expected a GPT family model (e.g., gpt-4o, gpt-4-turbo). Set OPENAI_EDIT_MODEL.";
        }
        if (!str_starts_with($audio, 'whisper-')) {
            $errors[] = "audio_model '{$audio}' is invalid. Expected an audio model like 'whisper-1'. Set OPENAI_AUDIO_MODEL.";
        }

        if (!empty($errors)) {
            $environment = $this->app->environment();
            if ($environment === 'production') {
                throw new ConfigurationValidationException(implode(' ', $errors));
            }
            // In non-production, log warnings but do not block boot to allow flexible testing/runtime overrides
            if ($this->app->bound(LoggingService::class)) {
                $loggingService = $this->app->make(LoggingService::class);
                $loggingService->logConfigurationEvent(
                    'warning',
                    'model_configuration',
                    $errors,
                    'service_provider'
                );
            }
        }
    }

    /**
     * Validate parameter ranges in configuration.
     *
     * @param array $config Configuration array
     * @throws ConfigurationValidationException When parameters are out of range
     */
    protected function validateParameterRanges(array $config): void
    {
        $parameterValidations = [
            'temperature' => ['min' => 0, 'max' => 2, 'type' => 'numeric'],
            'top_p' => ['min' => 0, 'max' => 1, 'type' => 'numeric'],
            'max_completion_tokens' => ['min' => 1, 'max' => 32768, 'type' => 'integer'],
            'presence_penalty' => ['min' => -2, 'max' => 2, 'type' => 'numeric'],
            'frequency_penalty' => ['min' => -2, 'max' => 2, 'type' => 'numeric'],
        ];

        foreach ($parameterValidations as $param => $validation) {
            if (isset($config[$param])) {
                $value = $config[$param];

                // Type validation (allow numeric strings for convenience)
                if ($validation['type'] === 'integer') {
                    if (!(is_int($value) || (is_numeric($value) && (int)$value == $value))) {
                        throw new ConfigurationValidationException(
                            "Configuration parameter '{$param}' must be an integer."
                        );
                    }
                    $value = (int)$value;
                } elseif ($validation['type'] === 'numeric') {
                    if (!is_numeric($value)) {
                        throw new ConfigurationValidationException(
                            "Configuration parameter '{$param}' must be numeric."
                        );
                    }
                    $value = (float)$value;
                }

                // Range validation
                if ($value < $validation['min']) {
                    throw new ConfigurationValidationException(
                        "Configuration parameter '{$param}' value {$value} is below minimum {$validation['min']}"
                    );
                }

                if ($value > $validation['max']) {
                    throw new ConfigurationValidationException(
                        "Configuration parameter '{$param}' value {$value} is above maximum {$validation['max']}"
                    );
                }
            }
        }
    }

    /**
     * Validate advanced nested configuration sections for types and ranges.
     */
    protected function validateAdvancedConfiguration(array $config): void
    {
        $errors = [];

        // persistence.driver
        $driver = $config['persistence']['driver'] ?? 'memory';
        if (!in_array($driver, ['memory', 'eloquent'], true)) {
            $errors[] = "persistence.driver must be 'memory' or 'eloquent'.";
        }

        // responses section
        if (isset($config['responses'])) {
            $resp = $config['responses'];
            if (!is_array($resp)) {
                $errors[] = 'responses must be an array.';
            } else {
                if (isset($resp['timeout']) && !is_numeric($resp['timeout'])) {
                    $errors[] = 'responses.timeout must be numeric (seconds).';
                } elseif (isset($resp['timeout']) && (int)$resp['timeout'] < 1) {
                    $errors[] = 'responses.timeout must be >= 1 second.';
                }
                if (isset($resp['idempotency_enabled']) && !is_bool($resp['idempotency_enabled'])) {
                    $errors[] = 'responses.idempotency_enabled must be boolean.';
                }
                if (array_key_exists('max_output_tokens', $resp) && $resp['max_output_tokens'] !== null && !(is_int($resp['max_output_tokens']) || (is_numeric(
                                $resp['max_output_tokens']
                            ) && (int)$resp['max_output_tokens'] == $resp['max_output_tokens']))) {
                    $errors[] = 'responses.max_output_tokens must be null or integer.';
                }
                if (isset($resp['retry'])) {
                    if (isset($resp['idempotency_bucket']) && !(is_int($resp['idempotency_bucket']) || (is_numeric(
                                    $resp['idempotency_bucket']
                                ) && (int)$resp['idempotency_bucket'] == $resp['idempotency_bucket']))) {
                        $errors[] = 'responses.idempotency_bucket must be integer (seconds).';
                    } elseif (isset($resp['idempotency_bucket']) && (int)$resp['idempotency_bucket'] < 1) {
                        $errors[] = 'responses.idempotency_bucket must be >= 1 second.';
                    }
                    $r = $resp['retry'];
                    if (!is_array($r)) {
                        $errors[] = 'responses.retry must be an array.';
                    } else {
                        if (isset($r['enabled']) && !is_bool($r['enabled'])) {
                            $errors[] = 'responses.retry.enabled must be boolean.';
                        }
                        if (isset($r['max_attempts']) && !(is_int($r['max_attempts']) || (is_numeric($r['max_attempts']) && (int)$r['max_attempts'] == $r['max_attempts']))) {
                            $errors[] = 'responses.retry.max_attempts must be integer.';
                        } elseif (isset($r['max_attempts']) && (int)$r['max_attempts'] < 1) {
                            $errors[] = 'responses.retry.max_attempts must be >= 1.';
                        }
                        if (isset($r['initial_delay']) && !is_numeric($r['initial_delay'])) {
                            $errors[] = 'responses.retry.initial_delay must be numeric (seconds).';
                        } elseif (isset($r['initial_delay']) && (float)$r['initial_delay'] < 0) {
                            $errors[] = 'responses.retry.initial_delay must be >= 0.';
                        }
                        if (isset($r['backoff_multiplier']) && !is_numeric($r['backoff_multiplier'])) {
                            $errors[] = 'responses.retry.backoff_multiplier must be numeric.';
                        } elseif (isset($r['backoff_multiplier']) && (float)$r['backoff_multiplier'] < 1.0) {
                            $errors[] = 'responses.retry.backoff_multiplier must be >= 1.0.';
                        }
                        if (isset($r['max_delay']) && !is_numeric($r['max_delay'])) {
                            $errors[] = 'responses.retry.max_delay must be numeric (seconds).';
                        } elseif (isset($r['max_delay']) && (float)$r['max_delay'] < 0) {
                            $errors[] = 'responses.retry.max_delay must be >= 0.';
                        }
                        if (isset($r['jitter']) && !is_bool($r['jitter'])) {
                            $errors[] = 'responses.retry.jitter must be boolean.';
                        }
                    }
                }
            }
        }

        // streaming section
        if (isset($config['streaming'])) {
            $s = $config['streaming'];
            if (!is_array($s)) {
                $errors[] = 'streaming must be an array.';
            } else {
                if (isset($s['enabled']) && !is_bool($s['enabled'])) {
                    $errors[] = 'streaming.enabled must be boolean.';
                }
                foreach (['buffer_size', 'chunk_size'] as $k) {
                    if (isset($s[$k]) && !(is_int($s[$k]) || (is_numeric($s[$k]) && (int)$s[$k] == $s[$k]))) {
                        $errors[] = "streaming.{$k} must be integer.";
                    } elseif (isset($s[$k]) && (int)$s[$k] < 1) {
                        $errors[] = "streaming.{$k} must be >= 1.";
                    }
                }
                foreach (['timeout', 'sse_timeout'] as $k) {
                    if (isset($s[$k]) && !(is_int($s[$k]) || (is_numeric($s[$k]) && (int)$s[$k] == $s[$k]))) {
                        $errors[] = "streaming.{$k} must be integer (seconds).";
                    } elseif (isset($s[$k]) && (int)$s[$k] < 1) {
                        $errors[] = "streaming.{$k} must be >= 1 second.";
                    }
                }
                if (isset($s['max_response_size']) && !(is_int($s['max_response_size']) || (is_numeric($s['max_response_size']) && (int)$s['max_response_size'] == $s['max_response_size']))) {
                    $errors[] = 'streaming.max_response_size must be integer (MB).';
                } elseif (isset($s['max_response_size']) && (int)$s['max_response_size'] < 1) {
                    $errors[] = 'streaming.max_response_size must be >= 1 MB.';
                }
            }
        }

        // tool_calling section
        if (isset($config['tool_calling'])) {
            $t = $config['tool_calling'];
            if (!is_array($t)) {
                $errors[] = 'tool_calling must be an array.';
            } else {
                if (isset($t['max_rounds']) && !(is_int($t['max_rounds']) || (is_numeric($t['max_rounds']) && (int)$t['max_rounds'] == $t['max_rounds']))) {
                    $errors[] = 'tool_calling.max_rounds must be integer.';
                } elseif (isset($t['max_rounds']) && (int)$t['max_rounds'] < 0) {
                    $errors[] = 'tool_calling.max_rounds must be >= 0.';
                }
                if (isset($t['executor']) && !in_array($t['executor'], ['sync', 'queue'], true)) {
                    $errors[] = "tool_calling.executor must be 'sync' or 'queue'.";
                }
                // If executor is queue, ensure a queue connection is configured to avoid runtime stalls.
                if (($t['executor'] ?? null) === 'queue') {
                    $queueConnection = config('ai-assistant.background_jobs.connection', config('queue.default'));
                    if (!is_string($queueConnection) || trim($queueConnection) === '') {
                        $errors[] = 'Set ai-assistant.tool_calling.executor=sync for local dev or configure queue connection AI_QUEUE_CONNECTION.';
                    }
                }
                if (isset($t['parallel']) && !is_bool($t['parallel'])) {
                    $errors[] = 'tool_calling.parallel must be boolean.';
                }
            }
        }

        // connection_pool section
        if (isset($config['connection_pool'])) {
            $cp = $config['connection_pool'];
            if (!is_array($cp)) {
                $errors[] = 'connection_pool must be an array.';
            } else {
                if (isset($cp['enabled']) && !is_bool($cp['enabled'])) {
                    $errors[] = 'connection_pool.enabled must be boolean.';
                }
                foreach (['max_connections', 'max_connections_per_host', 'timeout', 'idle_timeout'] as $k) {
                    if (isset($cp[$k]) && !(is_int($cp[$k]) || (is_numeric($cp[$k]) && (int)$cp[$k] == $cp[$k]))) {
                        $errors[] = "connection_pool.{$k} must be integer.";
                    } elseif (isset($cp[$k]) && (int)$cp[$k] < 0) {
                        $errors[] = "connection_pool.{$k} must be >= 0.";
                    }
                }
            }
        }

        if (!empty($errors)) {
            throw new ConfigurationValidationException(implode(' ', $errors));
        }
    }

    /**
     * Validate environment-specific settings.
     *
     * @param array $config Configuration array
     * @throws ConfigurationValidationException When environment settings are invalid
     */
    protected function validateWebhooksConfiguration(array $config): void
    {
        $webhooks = $config['webhooks'] ?? null;
        if (!is_array($webhooks)) {
            return; // nothing to validate
        }
        $enabled = (bool)($webhooks['enabled'] ?? false);
        if (!$enabled) {
            return; // validation applies only when webhooks are enabled
        }

        $errors = [];

        $secret = $webhooks['signing_secret'] ?? '';
        if (!is_string($secret) || trim($secret) === '') {
            $errors[] = 'webhooks.signing_secret must be a non-empty string when webhooks are enabled.';
        }

        $signatureHeader = $webhooks['signature_header'] ?? '';
        if (!is_string($signatureHeader) || trim($signatureHeader) === '') {
            $errors[] = 'webhooks.signature_header must be a non-empty string when webhooks are enabled.';
        }

        $timestampHeader = $webhooks['timestamp_header'] ?? '';
        if (!is_string($timestampHeader) || trim($timestampHeader) === '') {
            $errors[] = 'webhooks.timestamp_header must be a non-empty string when webhooks are enabled.';
        }

        $maxSkew = $webhooks['max_skew_seconds'] ?? 300;
        if (!is_numeric($maxSkew)) {
            $errors[] = 'webhooks.max_skew_seconds must be numeric.';
        } else {
            $intSkew = (int)$maxSkew;
            if ($intSkew < 1 || $intSkew > 86400) { // up to 1 day skew allowed
                $errors[] = 'webhooks.max_skew_seconds must be an integer between 1 and 86400.';
            }
        }

        if (!empty($errors)) {
            throw new ConfigurationValidationException(implode(' ', $errors));
        }
    }

    protected function validateEnvironmentSpecificSettings(array $config): void
    {
        $environment = $this->app->environment();

        // Production environment specific validations
        if ($environment === 'production') {
            // Ensure API key is not a test key
            if (isset($config['api_key']) && $this->isTestApiKey($config['api_key'])) {
                throw new ConfigurationValidationException(
                    'Test API key detected in production environment. Please use a valid production API key.'
                );
            }

            // Warn about high token limits in production
            if (isset($config['max_completion_tokens']) && $config['max_completion_tokens'] > 4096) {
                if ($this->app->bound(LoggingService::class)) {
                    $loggingService = $this->app->make(LoggingService::class);
                    $loggingService->logConfigurationEvent(
                        'warning',
                        'max_completion_tokens',
                        'High token limit in production may result in increased costs',
                        'service_provider'
                    );
                }
            }
        }

        // Development environment specific validations
        if (in_array($environment, ['local', 'development', 'testing'])) {
            // Allow more lenient validation for development
            if (empty($config['api_key'])) {
                if ($this->app->bound(LoggingService::class)) {
                    $loggingService = $this->app->make(LoggingService::class);
                    $loggingService->logConfigurationEvent(
                        'info',
                        'api_key',
                        'No API key configured in development environment',
                        'service_provider'
                    );
                }
            }
        }
    }

    /**
     * Check if an API key appears to be a test key.
     *
     * @param string $apiKey The API key to check
     * @return bool True if it appears to be a test key
     */
    protected function isTestApiKey(string $apiKey): bool
    {
        $testPatterns = [
            'sk-test',
            'sk-fake',
            'sk-demo',
            'sk-000000',
            'sk-111111',
            'sk-xxxxxxxx',
        ];

        $keyLower = strtolower($apiKey);

        foreach ($testPatterns as $pattern) {
            if (str_starts_with($keyLower, $pattern)) {
                return true;
            }
        }

        return false;
    }
}
